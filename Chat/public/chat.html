<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="pageTitle">Tontoo AI | Chat</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="main-layout">
        <div class="sidebar" id="chatSidebar">
            <div class="chat-sidebar-header">
                <img src="/icon.png" alt="Beschreibung des Icons" width="52" height="52">
                <button id="newChatBtn"><span style="font-size:30px;">+</span><span id="newChatBtnText" style="font-size:20px;"></span></button>
                <p id="toggleSidebarBtn" title=""></p>
            </div>
            <div class="chat-list" id="chatList">
                <!-- Chat-Liste wird hier dynamisch geladen -->
            </div>
        </div>

        <div class="content-area">
            <div class="chat-main">
                <div class="chat-messages" id="chatMessages">
                    <!-- Nachrichten werden hier dynamisch geladen -->
                </div>
                <div class="chat-input-area">
                    <div class="feature-menu-container">
                        <button id="featureMenuBtn" title="Features">
                            <i class="fas fa-plus"></i>
                        </button>
                        <div class="feature-menu" id="featureMenu">
                            <button class="feature-menu-item" id="codeInterpreterBtn" onclick="toggleFeature('Codeinterpreter')">
                                <i class="fas fa-code"></i>Codeinterpreter
                            </button>
                            <button class="feature-menu-item" id="websearchBtn" onclick="toggleFeature('Websearch')">
                                <i class="fas fa-search"></i>Websearch
                            </button>
                            <button class="feature-menu-item" id="deepSearchBtn" onclick="toggleFeature('DeepSearch')">
                                <i class="fas fa-search-plus"></i>DeepSearch
                            </button>
                        </div>
                    </div>
                    
                    <textarea id="messageInput" placeholder="" rows="1"></textarea>
                    <button id="sendMessageBtn"><i class="fas fa-paper-plane"></i></button>
                    <select id="modelSelector" class="model-selector"></select>
                </div>
            </div>

            <div class="user-info-footer" id="userInfoFooter">
                <i class="fas fa-user icon"></i>
                <span id="userTokensSummary"></span>
                <div class="user-info-popup" id="userInfoPopup">
                    <p>⚡ genutzt: <span id="popupUsedTokens"></span></p>
                    <p>⚡ Max: <span id="popupMaxTokens"></span></p>
                    <button onclick="window.location.href='/settings.html'"><i class="fas fa-cog"></i> Einstellungen</button>
                    <button id="logoutBtn"><i class="fas fa-sign-out-alt"></i> Abmelden</button>
                </div>
            </div>
        </div>
    </div>
    <div id="popupContainer"></div>
    <script>
        // Globale Funktionen
        window.copyCode = function(button) {
            const codeElement = button.closest('.code-block, .execution-code, .execution-output').querySelector('code');
            const textToCopy = codeElement.textContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            }).catch(err => {
                console.error('Fehler beim Kopieren des Codes:', err);
                showPopup('Fehler beim Kopieren des Codes.', 'error');
            });
        };

        let activeFeature = null; // Track active feature (null, 'Codeinterpreter', 'Websearch', 'DeepSearch')

        function toggleFeature(featureName) {
            console.log('Toggling feature:', featureName);

            if (activeFeature && activeFeature !== featureName) {
                showPopup(`Nur eine Funktion kann aktiv sein. Deaktiviere ${activeFeature} zuerst.`, 'info');
                return;
            }

            const buttonIdMap = {
                'Codeinterpreter': 'codeInterpreterBtn',
                'Websearch': 'websearchBtn',
                'DeepSearch': 'deepSearchBtn'
            };
            const buttonId = buttonIdMap[featureName];
            const button = document.getElementById(buttonId);
            if (!button) {
                console.error(`Button with ID ${buttonId} not found`);
                showPopup(`Fehler: Schaltfläche ${featureName} nicht gefunden.`, 'error');
                return;
            }

            if (activeFeature === featureName) {
                activeFeature = null;
                button.classList.remove('active');
                showPopup(`${featureName} deaktiviert.`, 'info');
            } else {
                activeFeature = featureName;
                document.querySelectorAll('.feature-menu-item').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                showPopup(`${featureName} aktiviert.`, 'success');
            }
            document.getElementById('featureMenu').classList.remove('active');
        }

        async function authenticatedFetch(url, options = {}) {
            const token = localStorage.getItem('authToken');
            if (!token) {
                window.location.href = '/login.html';
                return;
            }
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`,
                ...options.headers
            };
            const response = await fetch(url, { ...options, headers });
            if (response.status === 401 || response.status === 403) {
                localStorage.removeItem('authToken');
                window.location.href = '/login.html';
                throw new Error('Nicht authentifiziert oder nicht autorisiert.');
            }
            return response;
        }

        const popupContainer = document.getElementById('popupContainer');
        function showPopup(message, type = 'error') {
            const popup = document.createElement('div');
            popup.classList.add('popup', type);
            popup.textContent = message;
            popupContainer.appendChild(popup);
            setTimeout(() => popup.remove(), 5000);
        }

        document.addEventListener('DOMContentLoaded', () => {
            let lang = {};
            let userLang = 'EN';
            async function loadLangFile(langCode) {
                try {
                    const res = await fetch(`/Lang_${langCode}.json`);
                    lang = await res.json();
                } catch (error) {
                    console.error('Fehler beim Laden der Sprachdatei:', error);
                }
            }
            async function getUserLanguage() {
                try {
                    const token = localStorage.getItem('authToken');
                    if (!token) return 'EN';
                    const res = await fetch('/api/user/me', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (!res.ok) return 'EN';
                    const user = await res.json();
                    return user.panelLanguage || 'EN';
                } catch {
                    return 'EN';
                }
            }
            (async () => {
                userLang = await getUserLanguage();
                await loadLangFile(userLang);

                document.getElementById('newChatBtnText').textContent = lang.new_chat || 'New Chat';
                document.getElementById('toggleSidebarBtn').title = lang.chat || 'Chat';
                document.getElementById('messageInput').placeholder = lang.send || 'Nachricht eingeben...';
            })();

            const featureMenuBtn = document.getElementById('featureMenuBtn');
            const featureMenu = document.getElementById('featureMenu');
            
            featureMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                featureMenu.classList.toggle('active');
            });
            
            document.addEventListener('click', (e) => {
                if (!featureMenu.contains(e.target) && e.target !== featureMenuBtn) {
                    featureMenu.classList.remove('active');
                }
            });
            
            featureMenu.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            const chatSidebar = document.getElementById('chatSidebar');
            const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
            const newChatBtn = document.getElementById('newChatBtn');
            const chatList = document.getElementById('chatList');
            const chatMessages = document.getElementById('chatMessages');
            const messageInput = document.getElementById('messageInput');
            const sendMessageBtn = document.getElementById('sendMessageBtn');
            const modelSelector = document.getElementById('modelSelector');
            const logoutBtn = document.getElementById('logoutBtn');

            let currentChatId = null;
            let isGeneratingResponse = false;
            let abortController = new AbortController();
            let currentMessageId = null;

            (async () => {
                try {
                    const response = await fetch('/api/general-config');
                    const config = await response.json();
                    document.getElementById('pageTitle').textContent = config['html-titel'].replace('%name', 'Chat');
                } catch (error) {
                    console.error('Fehler beim Laden der allgemeinen Konfiguration:', error);
                }
            })();
            
            async function loadUserInfo() {
                try {
                    const response = await authenticatedFetch('/api/user/me');
                    if (!response.ok) throw new Error('Benutzerdaten konnten nicht geladen werden.');
                    const userData = await response.json();
                    const usedTokens = userData['used-tokens'] || 0;
                    const maxTokens = userData['max-tokens'] === '--' ? '∞' : userData['max-tokens'];

                    document.getElementById('userTokensSummary').textContent = `${usedTokens} / ${maxTokens} ⚡`;
                    document.getElementById('popupUsedTokens').textContent = usedTokens;
                    document.getElementById('popupMaxTokens').textContent = maxTokens;

                    if (userData['max-tokens'] !== '--' && usedTokens >= parseInt(userData['max-tokens'])) {
                        messageInput.disabled = true;
                        sendMessageBtn.disabled = true;
                        messageInput.placeholder = 'Tägliches Token-Limit erreicht.';
                        showPopup('Ihr tägliches Token-Limit ist erreicht.', 'error');
                    } else {
                        messageInput.disabled = false;
                        sendMessageBtn.disabled = false;
                        messageInput.placeholder = 'Nachricht eingeben...';
                    }
                } catch (error) {
                    console.error('Fehler beim Laden der Benutzerinfo:', error);
                }
            }

            function logout() {
                authenticatedFetch('/api/logout', { method: 'POST' })
                    .then(() => {
                        localStorage.removeItem('authToken');
                        window.location.href = '/login.html';
                    })
                    .catch(error => {
                        console.error('Logout fehlgeschlagen:', error);
                        showPopup('Logout fehlgeschlagen.', 'error');
                    });
            }
            logoutBtn.addEventListener('click', logout);
            
            const userInfoFooter = document.getElementById('userInfoFooter');
            const userInfoPopup = document.getElementById('userInfoPopup');
            userInfoFooter.addEventListener('click', (event) => {
                if (!userInfoPopup.contains(event.target)) userInfoPopup.classList.toggle('active');
            });
            document.addEventListener('click', (event) => {
                if (!userInfoFooter.contains(event.target)) userInfoPopup.classList.remove('active');
            });

            toggleSidebarBtn.addEventListener('click', () => {
                chatSidebar.classList.toggle('collapsed');
            });

            newChatBtn.addEventListener('click', () => {
                if (isGeneratingResponse) {
                    stopGeneration();
                    return;
                }
                currentChatId = null;
                chatMessages.innerHTML = '';
                document.querySelectorAll('.chat-list-item').forEach(item => item.classList.remove('active'));
                messageInput.focus();
            });

            async function loadChatList() {
                try {
                    const response = await authenticatedFetch('/api/chats');
                    if (!response.ok) throw new Error('Chat-Liste konnte nicht geladen werden.');
                    const chats = await response.json();
                    chatList.innerHTML = '';
                    const sortedChats = chats.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    sortedChats.forEach(chat => {
                        const chatItem = document.createElement('div');
                        chatItem.classList.add('chat-list-item');
                        chatItem.dataset.chatId = chat.id;
                        if (currentChatId === chat.id) chatItem.classList.add('active');
                        chatItem.innerHTML = `
                            <span class="chat-list-item-title">${chat.title}</span>
                            <div class="chat-list-item-actions">
                                <button class="rename-chat-btn" data-chat-id="${chat.id}" title="Umbenennen"><i class="fas fa-edit"></i></button>
                                <button class="delete-chat-btn danger" data-chat-id="${chat.id}" title="Löschen"><i class="fas fa-trash"></i></button>
                            </div>`;
                        chatList.appendChild(chatItem);
                    });
                } catch (error) {
                    console.error('Fehler beim Laden der Chat-Liste:', error);
                }
            }

            chatList.addEventListener('click', (e) => {
                const target = e.target;
                const chatItem = target.closest('.chat-list-item');
                if (!chatItem) return;

                const chatId = chatItem.dataset.chatId;
                if (target.closest('.rename-chat-btn')) {
                    renameChat(chatId);
                } else if (target.closest('.delete-chat-btn')) {
                    deleteChat(chatId);
                } else {
                    selectChat(chatId);
                }
            });

            async function selectChat(chatId) {
                if (isGeneratingResponse) {
                    stopGeneration();
                    return;
                }
                currentChatId = chatId;
                document.querySelectorAll('.chat-list-item').forEach(item => item.classList.remove('active'));
                document.querySelector(`.chat-list-item[data-chat-id="${chatId}"]`)?.classList.add('active');
                try {
                    const response = await authenticatedFetch(`/api/chats/${chatId}`);
                    if (!response.ok) throw new Error('Chat-Verlauf konnte nicht geladen werden.');
                    const chatData = await response.json();
                    renderChatMessages(chatData.messages);
                } catch (error) {
                    console.error('Fehler beim Laden des Chat-Verlaufs:', error);
                    showPopup('Fehler beim Laden des Chat-Verlaufs.', 'error');
                }
            }

            async function renameChat(chatId) {
                const newTitle = prompt('Neuen Chat-Namen eingeben:');
                if (newTitle && newTitle.trim()) {
                    try {
                        await authenticatedFetch(`/api/chats/${chatId}/rename`, {
                            method: 'POST',
                            body: JSON.stringify({ title: newTitle.trim() })
                        });
                        loadChatList();
                    } catch (error) {
                        showPopup('Fehler beim Umbenennen.', 'error');
                    }
                }
            }

            async function deleteChat(chatId) {
                if (confirm('Sind Sie sicher, dass Sie diesen Chat löschen möchten?')) {
                    try {
                        await authenticatedFetch(`/api/chats/${chatId}`, { method: 'DELETE' });
                        if (currentChatId === chatId) {
                            currentChatId = null;
                            chatMessages.innerHTML = '';
                        }
                        loadChatList();
                    } catch (error) {
                        showPopup('Fehler beim Löschen.', 'error');
                    }
                }
            }
            
            async function loadModels() {
                try {
                    const response = await authenticatedFetch('/api/models');
                    if (!response.ok) throw new Error('Modelle konnten nicht geladen werden.');
                    const models = await response.json();
                    modelSelector.innerHTML = '';
                    if (Object.keys(models).length === 0) {
                        modelSelector.innerHTML = '<option value="">Keine Modelle verfügbar</option>';
                        sendMessageBtn.disabled = true;
                        messageInput.disabled = true;
                        messageInput.placeholder = "Keine Modelle konfiguriert.";
                    } else {
                        for (const modelId in models) {
                            const option = document.createElement('option');
                            option.value = modelId;
                            option.textContent = models[modelId];
                            modelSelector.appendChild(option);
                        }
                    }
                } catch (error) {
                    console.error("Fehler beim Laden der Modelle:", error);
                    showPopup("Fehler beim Laden der Modelle.", "error");
                }
            }

            async function stopGeneration() {
                if (!isGeneratingResponse) return;
                
                try {
                    const response = await authenticatedFetch('/api/stop', {
                        method: 'POST',
                        body: JSON.stringify({ messageId: currentMessageId })
                    });
                    
                    if (response.ok) {
                        abortController.abort();
                        isGeneratingResponse = false;
                        currentMessageId = null;
                        sendMessageBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                        messageInput.disabled = false;
                        messageInput.focus();
                    }
                } catch (error) {
                    console.error('Fehler beim Stoppen der Generation:', error);
                    showPopup('Fehler beim Stoppen.', 'error');
                }
            }

            function escapeHtml(text) {
                return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }

            function formatMessageContent(content, websearchResults = null, deepsearchResults = null, codeExecutionResults = null) {
                const codeBlockPlaceholders = [];
                content = content.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
                    const placeholder = `___CODE_BLOCK_${codeBlockPlaceholders.length}___`;
                    codeBlockPlaceholders.push({ 
                        type: 'block', 
                        content: codeContent.trim(),
                        placeholder
                    });
                    return placeholder;
                });

                const inlineCodePlaceholders = [];
                content = content.replace(/`([^`]+)`/g, (match, codeContent) => {
                    const placeholder = `___INLINE_CODE_${inlineCodePlaceholders.length}___`;
                    inlineCodePlaceholders.push({
                        type: 'inline',
                        content: codeContent,
                        placeholder
                    });
                    return placeholder;
                });

                let formattedContent = escapeHtml(content);
                
                formattedContent = formattedContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
                formattedContent = formattedContent.replace(/\n/g, '<br>');
                
                codeBlockPlaceholders.forEach(item => {
                    const language = item.content.split('\n')[0].match(/^(\w+)/);
                    const lang = language ? language[1] : 'text';
                    const code = language ? item.content.substring(language[0].length).trim() : item.content;
                    
                    formattedContent = formattedContent.replace(
                        item.placeholder, 
                        `<div class="code-block"><div class="code-header"><span>${lang}</span><button onclick="copyCode(this)"><i class="fas fa-copy"></i></button></div><pre><code class="language-${lang}">${escapeHtml(code)}</code></pre></div>`
                    );
                });
                
                inlineCodePlaceholders.forEach(item => {
                    formattedContent = formattedContent.replace(
                        item.placeholder,
                        `<code class="inline-code">${escapeHtml(item.content)}</code>`
                    );
                });

                // Websearch Results
                if (websearchResults && websearchResults.quellen && Array.isArray(websearchResults.quellen)) {
                    const urlsHtml = websearchResults.quellen
                        .filter(url => url && typeof url === 'string' && url.startsWith('http'))
                        .map(url => `<a href="${url}" target="_blank" class="websearch-url">${url}</a>`)
                        .join('<br>');
                    if (urlsHtml) {
                        formattedContent += `<div class="websearch-results"><strong>Websearch Quellen:</strong><br>${urlsHtml}</div>`;
                    }
                }

                // Deepsearch Results
                if (deepsearchResults && deepsearchResults.quellen && Array.isArray(deepsearchResults.quellen)) {
                    const urlsHtml = deepsearchResults.quellen
                        .filter(url => url && typeof url === 'string' && url.startsWith('http'))
                        .map(url => `<a href="${url}" target="_blank" class="deepsearch-url">${url}</a>`)
                        .join('<br>');
                    if (urlsHtml) {
                        formattedContent += `<div class="deepsearch-results"><strong>Deepsearch Quellen:</strong><br>${urlsHtml}</div>`;
                    }
                }

                // Code Execution Results
                if (codeExecutionResults) {
                    let parsedResults;
                    try {
                        parsedResults = typeof codeExecutionResults === 'string' ? JSON.parse(codeExecutionResults) : codeExecutionResults;
                    } catch (e) {
                        console.error('Fehler beim Parsen der Codeausführungsergebnisse:', e, codeExecutionResults);
                        return formattedContent;
                    }

                    if (!parsedResults || !parsedResults.code) {
                        console.warn('Keine gültigen Codeausführungsergebnisse:', parsedResults);
                        return formattedContent;
                    }

                    const packages = parsedResults.packages || [];
                    const packagesHtml = packages.length > 0 
                        ? `<div class="packages-list">${packages.map(pkg => `<span class="package-tag">${pkg}</span>`).join(' ')}</div>`
                        : '<span>Keine</span>';

                    const status = parsedResults.status || (parsedResults.output ? 'success' : parsedResults.error ? 'error' : 'unknown');
                    const statusClass = status === 'success' ? 'status-success' : 'status-error';
                    const outputClass = status === 'success' ? 'execution-output' : 'execution-output execution-error';
                    const output = parsedResults.output || parsedResults.error || 'Keine Ausgabe verfügbar';

                    formattedContent += `
                        <div class="codeexecution-results">
                            <div class="execution-header">
                                <div class="execution-title">
                                    <i class="fas fa-code"></i> Code Ausführung
                                </div>
                                <div class="execution-language">${parsedResults.language || 'Unbekannt'}</div>
                            </div>
                            
                            <div class="execution-status ${statusClass}">
                                ${status.toUpperCase()}
                            </div>
                            
                            <div class="execution-info">
                                <div class="execution-info-item">
                                    <strong>Sprache:</strong>
                                    <span>${parsedResults.language || 'Unbekannt'} ${parsedResults.version || ''}</span>
                                </div>
                                <div class="execution-info-item">
                                    <strong>Internet:</strong>
                                    <span>${parsedResults.internet === 'true' ? 'Aktiviert' : 'Deaktiviert'}</span>
                                </div>
                                <div class="execution-info-item">
                                    <strong>Pakete:</strong>
                                    ${packagesHtml}
                                </div>
                                ${parsedResults.description ? `<div class="execution-info-item"><strong>Beschreibung:</strong><span>${escapeHtml(parsedResults.description)}</span></div>` : ''}
                            </div>
                            
                            <div class="execution-code">
                                <div class="code-header"><span>${parsedResults.language || 'Code'}</span><button onclick="copyCode(this)"><i class="fas fa-copy"></i></button></div>
                                <pre><code class="language-${parsedResults.language || 'text'}">${escapeHtml(parsedResults.code)}</code></pre>
                            </div>
                            
                            <div class="${outputClass}">
                                <div class="code-header"><span>Ausgabe</span><button onclick="copyCode(this)"><i class="fas fa-copy"></i></button></div>
                                <pre><code>${escapeHtml(output)}</code></pre>
                            </div>
                        </div>
                    `;
                }
                
                return formattedContent;
            }

            function addMessageToChat(message) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message', message.sender);
                messageElement.dataset.messageId = message.id;

                const iconHtml = message.sender === 'user' ? 'DU' : '<img src="/icon.png" alt="AI Icon" width="32" height="32">';
                const infoHtml = message.sender === 'ai' && message.tokens !== undefined
                    ? `<div class="chat-message-info">⚡ ${message.tokens} ⌛ ${message.time}s</div>`
                    : '';

                let contentHtml = formatMessageContent(
                    message.content, 
                    message.websearchResults, 
                    message.deepsearchResults,
                    message.codeexecution_results || message.codeExecutionResults
                );

                if (message.isWebsearchPending) {
                    contentHtml = '<i class="fas fa-spinner fa-spin websearch-loading"></i> Websearch läuft...';
                }
                if (message.isDeepsearchPending) {
                    contentHtml = '<i class="fas fa-spinner fa-spin deepsearch-loading"></i> Deepsearch läuft...';
                }
                if (message.isCodeExecutionPending) {
                    contentHtml = '<i class="fas fa-spinner fa-spin codeinterpreter-loading"></i> Code wird ausgeführt...';
                }

                messageElement.innerHTML = `
                    <div class="icon">${iconHtml}</div>
                    <div class="chat-bubble-container">
                        <div class="chat-bubble">${contentHtml}</div>
                        ${infoHtml}
                    </div>`;
                
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            function updateLastAiMessage(chunk, isDone = false, stats = {}, websearchResults = null, deepsearchResults = null, codeExecutionResults = null) {
                let lastMessageElement = chatMessages.querySelector('.chat-message.ai:last-child');
                
                if (!lastMessageElement) {
                    addMessageToChat({ id: `msg_${Date.now()}_ai`, sender: 'ai', content: '' });
                    lastMessageElement = chatMessages.querySelector('.chat-message.ai:last-child');
                }
                
                const bubble = lastMessageElement.querySelector('.chat-bubble');
                const currentContent = bubble.dataset.rawContent || '';
                const newContent = currentContent + chunk;
                bubble.dataset.rawContent = newContent;
                
                bubble.innerHTML = formatMessageContent(newContent, websearchResults, deepsearchResults, codeExecutionResults);

                if (isDone) {
                    const infoContainer = document.createElement('div');
                    infoContainer.classList.add('chat-message-info');
                    infoContainer.innerHTML = `⚡ ${stats.tokens} ⌛ ${stats.time}s`;
                    lastMessageElement.querySelector('.chat-bubble-container').appendChild(infoContainer);
                }
                
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            function renderChatMessages(messages) {
                chatMessages.innerHTML = '';
                messages.forEach(msg => {
                    console.log('Rendering message:', msg.id, 'with codeexecution_results:', msg.codeexecution_results);
                    addMessageToChat(msg);
                });
                console.log('Finished rendering all messages');
            }

            async function sendMessage() {
                const content = messageInput.value.trim();
                if (!content || isGeneratingResponse) {
                    console.warn('SendMessage abgebrochen: Entweder kein Inhalt oder Generierung läuft bereits.');
                    return;
                }

                isGeneratingResponse = true;
                currentMessageId = `msg_${Date.now()}_ai`;
                sendMessageBtn.innerHTML = '<i class="fas fa-stop"></i>';
                messageInput.value = '';
                messageInput.disabled = true;

                addMessageToChat({ 
                    id: `msg_${Date.now()}_user`, 
                    sender: 'user', 
                    content 
                });

                let loadingMessage = { 
                    id: currentMessageId, 
                    sender: 'ai', 
                    content: '' 
                };

                if (activeFeature === 'Codeinterpreter') {
                    loadingMessage.isCodeExecutionPending = true;
                } else if (activeFeature === 'Websearch') {
                    loadingMessage.isWebsearchPending = true;
                } else if (activeFeature === 'DeepSearch') {
                    loadingMessage.isDeepsearchPending = true;
                } else {
                    loadingMessage.content = '<i class="fas fa-spinner fa-spin normal-loading"></i> KI antwortet...';
                }

                addMessageToChat(loadingMessage);

                try {
                    abortController = new AbortController();
                    let response;

                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Request-Timeout nach 10 Minuten')), 600000)
                    );

                    if (activeFeature === 'Codeinterpreter') {
                        console.log('Sending Code Interpreter request');
                        response = await Promise.race([
                            authenticatedFetch('/api/codeinterpreter', {
                                method: 'POST',
                                headers: { 'X-Chat-ID': currentChatId || '' },
                                body: JSON.stringify({ message: content, model: modelSelector.value }),
                                signal: abortController.signal
                            }),
                            timeoutPromise
                        ]);
                    } else if (activeFeature === 'Websearch') {
                        console.log('Sending Websearch request');
                        response = await Promise.race([
                            authenticatedFetch('/api/websearch', {
                                method: 'POST',
                                headers: { 'X-Chat-ID': currentChatId || '' },
                                body: JSON.stringify({ message: content, model: modelSelector.value }),
                                signal: abortController.signal
                            }),
                            timeoutPromise
                        ]);
                    } else if (activeFeature === 'DeepSearch') {
                        console.log('Sending DeepSearch request');
                        response = await Promise.race([
                            authenticatedFetch('/api/deepsearch', {
                                method: 'POST',
                                headers: { 'X-Chat-ID': currentChatId || '' },
                                body: JSON.stringify({ message: content, model: modelSelector.value }),
                                signal: abortController.signal
                            }),
                            timeoutPromise
                        ]);
                    } else {
                        console.log('Sending standard chat request');
                        response = await Promise.race([
                            authenticatedFetch('/api/chat/send', {
                                method: 'POST',
                                headers: { 'X-Chat-ID': currentChatId || '' },
                                body: JSON.stringify({ message: content, model: modelSelector.value }),
                                signal: abortController.signal
                            }),
                            timeoutPromise
                        ]);
                    }

                    if (!response.ok) {
                        let errText = 'Fehler vom Server';
                        try {
                            const errJson = await response.json();
                            errText = errJson.details || errJson.message || JSON.stringify(errJson);
                        } catch {
                            try { errText = await response.text(); } catch (_) {}
                        }
                        throw new Error(errText);
                    }

                    const isStream = response.body && typeof response.body.getReader === 'function';

                    if (!isStream) {
                        let data;
                        try {
                            data = await response.json();
                        } catch (e) {
                            const text = await response.text().catch(() => '');
                            throw new Error(text || 'Ungültige Server-Antwort.');
                        }

                        if (data && data.type === 'guard' && data.allowed === false) {
                            const lastUserMsg = chatMessages.querySelector('.chat-message.user:last-child .chat-bubble');
                            if (lastUserMsg) {
                                lastUserMsg.style.background = '#FF4444';
                                lastUserMsg.style.color = '#fff';
                                lastUserMsg.innerHTML += `<br><strong>Unangemessen!</strong>`;
                            }
                        } else if (data && data.type === 'error') {
                            throw new Error(data.details || data.message || 'Serverfehler');
                        } else {
                            if (data && data.message) {
                                showPopup(data.message, 'success');
                            }
                        }

                        isGeneratingResponse = false;
                        currentMessageId = null;
                        sendMessageBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                        messageInput.disabled = false;
                        messageInput.focus();
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let aiResponseContent = '';
                    let streamEnded = false;
                    let websearchResults = null;
                    let deepsearchResults = null;
                    let codeExecutionResults = null;
                    let buffer = '';
                    
                    const lastAiMessage = chatMessages.querySelector('.chat-message.ai:last-child');
                    if (lastAiMessage) {
                        lastAiMessage.remove();
                    }

                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                streamEnded = true;
                                break;
                            }

                            const decodedChunk = decoder.decode(value, { stream: true });
                            buffer += decodedChunk;
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || '';

                            for (const line of lines) {
                                const trimmedLine = line.trim();
                                if (!trimmedLine) continue;

                                let data;
                                try {
                                    data = JSON.parse(trimmedLine);
                                } catch (parseError) {
                                    console.warn('Konnte Stream-Zeile nicht parsen:', trimmedLine, parseError);
                                    continue;
                                }

                                if (data.type === 'token') {
                                    aiResponseContent += data.token;
                                    updateLastAiMessage(data.token, false, {}, websearchResults, deepsearchResults, codeExecutionResults);
                                } else if (data.type === 'websearch') {
                                    websearchResults = data.websearchResults;
                                    updateLastAiMessage('', false, {}, websearchResults, deepsearchResults, codeExecutionResults);
                                } else if (data.type === 'deepsearch') {
                                    deepsearchResults = data.deepsearchResults;
                                    updateLastAiMessage('', false, {}, websearchResults, deepsearchResults, codeExecutionResults);
                                } else if (data.type === 'codeexecution') {
                                    codeExecutionResults = data.codeExecutionResults;
                                    updateLastAiMessage('', false, {}, websearchResults, deepsearchResults, codeExecutionResults);
                                } else if (data.type === 'progress') {
                                    updateLastAiMessage(data.message + '\n', false, {}, websearchResults, deepsearchResults, codeExecutionResults);
                                } else if (data.type === 'end') {
                                    updateLastAiMessage('', true, { tokens: data.tokens, time: data.time }, websearchResults, deepsearchResults, codeExecutionResults);
                                    if (data.isNewChat) currentChatId = data.chatId;
                                    loadChatList();
                                    loadUserInfo();
                                    streamEnded = true;
                                    if (activeFeature) {
                                        const buttonIdMap = {
                                            'Codeinterpreter': 'codeInterpreterBtn',
                                            'Websearch': 'websearchBtn',
                                            'DeepSearch': 'deepSearchBtn'
                                        };
                                        document.getElementById(buttonIdMap[activeFeature]).classList.remove('active');
                                        showPopup(`${activeFeature} deaktiviert.`, 'info');
                                        activeFeature = null;
                                    }
                                    break;
                                } else if (data.type === 'error') {
                                    throw new Error(data.details || data.message || 'Fehler vom Server im Stream');
                                }
                            }

                            if (streamEnded) break;
                        }
                    } catch (streamError) {
                        if (streamError.name !== 'AbortError' && streamError.message !== 'Request-Timeout nach 10 Minuten') {
                            console.error('Stream-Fehler:', streamError);
                            updateLastAiMessage(`\n\n**Fehler:** ${streamError.message}`, false, {}, websearchResults, deepsearchResults, codeExecutionResults);
                        }
                    } finally {
                        reader.releaseLock();
                    }

                } catch (error) {
                    if (error.name !== 'AbortError' && error.message !== 'Request-Timeout nach 10 Minuten') {
                        console.error('Fehler bei der KI-Antwort:', error);
                        updateLastAiMessage(`\n\n**Fehler:** ${error.message}`, false, {}, null, null, null);
                    }
                } finally {
                    isGeneratingResponse = false;
                    currentMessageId = null;
                    sendMessageBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                    messageInput.disabled = false;
                    messageInput.focus();
                }
            }

            sendMessageBtn.addEventListener('click', () => {
                if (isGeneratingResponse) {
                    stopGeneration();
                } else {
                    sendMessage();
                }
            });

            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (isGeneratingResponse) {
                        stopGeneration();
                    } else {
                        sendMessage();
                    }
                }
            });

            loadUserInfo();
            loadChatList();
            loadModels();
        });
    </script>
</body>
</html>
